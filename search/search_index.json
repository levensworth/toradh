{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Toradh","text":"<p>Your python minimalistic library for better error management and flow control.</p>"},{"location":"#installation","title":"Installation:","text":"<p>Simply run:</p> <pre><code>pip install toradh\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p><code>toradh</code> has 2 main primitives available for use, <code>Result</code> and <code>Option</code>.</p>"},{"location":"#option","title":"<code>Option</code>:","text":"<p>The use for the <code>Option</code> primitive is to offer a better alternative to the default <code>typing.Optional</code> which translates into <code>T | None</code> (where <code>T</code> represents any value).</p> <p>Here you have some examples:</p> <pre><code>from toradh import Option\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: int\n    surname: Option[str]\n\nuser = User(id=1, surname=Option.of('doe'))\nuser.surname.is_some() # returns True\nuser.surname.unwrap() # 'doe'\nuser.surname.unwrap_or('default')# 'doe'\n\nempty_user = User(id=1, surname=Option.of(None))\nempty_user.surname.is_some() # returns False\nempty_user.surname.unwrap() # raise ValueError\nempty_user.surname.unwrap_or('default')# 'default'\n</code></pre>"},{"location":"#result","title":"<code>Result</code>:","text":"<pre><code>from toradh import Result, Ok, Err\n\ndef make_payment(to: str, amount: int) -&gt; Result[bool, KeyError | ValueError]:\n    \"\"\"Function which performs a payment transaction to a given address by incrementing \n    it's original balance by the given amount.\n\n    Args:\n        to (str): Address to which the deposit will be given.\n        amount (int): Amount to deposit.\n\n    Return:\n        Result[bool, KeyError | ValueError]: True if operation successfully completed, False\n        if the payment failed for runtime reasons.\n\n        Errors:\n            KeyError: Means the address does not exists\n            ValueError: Means the amount is not a positive integer.\n    \"\"\"\n    ...\n\n\npayment_result = make_payment(to='0x001', amount=-100)\n\nmatch payment_result.kind():\n    case True:\n        # then it was a successful invocation\n        handle_successful_payment(...)\n    case False:\n        handle_failed_payment(...)\n    case KeyError():\n        # the address was wrong\n        alert_wrong_address(...)\n    case ValueError():\n        # the amount was incorrect\n        alert_illegal_amount(...)\n</code></pre>"},{"location":"why_use_result/","title":"Why use Result","text":"<p>Let's imagine we are developing an application which uses <code>carts</code>, and we need to  create the <code>Aggregate</code> for <code>add_to_cart</code> as you can see below:</p> <pre><code>from dataclasses import dataclass, field\nimport logging\nfrom typing import Protocol, Optional\n\n\n@dataclass\nclass Cart:\n    id: int\n    items: list[str] = field(default_factory=list)\n\n\nclass CartService(Protocol):\n    def add_item(self, cart: Cart, item: str) -&gt; Cart: ...\n\n\nclass CartRepository(Protocol):\n    def get_by_id(self, id: int) -&gt; Optional[Cart]: ...\n\n    def update_cart_items(self, cart: Cart) -&gt; bool: ...\n\n\ndef add_to_cart_aggregate(\n    cart_id: int, item: str, service: CartService, repository: CartRepository\n) -&gt; None:\n    cart = repository.get_by_id(cart_id)\n    if not cart:\n        logging.error(f\"cart {cart_id} not found\")\n        return\n\n    updated = service.add_item(cart, item=item)\n    repository.update_cart_items(updated)\n</code></pre> <p>The problem which this code is that the <code>CartService</code> and  <code>CartRepository</code> both have completely  valid reasons for why they might fail in ways that are not clear from just ready the code above.</p> <ul> <li>What if the the item already exists in the cart?</li> <li>what if the item can't be part of the cart for business related reasons?</li> </ul> <p>The code just isn't expressive enough.</p>"},{"location":"why_use_result/#make-code-more-expressive","title":"Make code more expressive:","text":"<p>Let's look at the above example but using <code>Result</code>:</p> <pre><code>from dataclasses import dataclass, field\nimport logging\nfrom typing import Protocol\n\nfrom toradh import  Option, Result\n\n\n\n@dataclass\nclass Cart:\n    id: int\n    items: list[str] = field(default_factory=list)\n\n\nclass InvalidItemError(RuntimeError): ...\n\n\nclass DuplicateItemInCartError(RuntimeError): ...\n\n\nclass CartNotFoundError(RuntimeError): ...\n\n\nclass CartService(Protocol):\n    def add_item(\n        self, cart: Cart, item: str\n    ) -&gt; Result[Cart, InvalidItemError | DuplicateItemInCartError]: ...\n\n\nclass CartRepository(Protocol):\n    def get_by_id(self, id: int) -&gt; Option[Cart]: ...\n\n    def update_cart_items(self, cart: Cart) -&gt; Result[bool, CartNotFoundError]: ...\n\n\ndef add_to_cart_aggregate(\n    cart_id: int, item: str, service: CartService, repository: CartRepository\n) -&gt; None:\n    cart = repository.get_by_id(cart_id)\n    if cart.is_nothing():\n        raise CartNotFoundError()\n\n    service_res = service.add_item(cart, item=item)\n    match service_res.kind():\n        case Cart():\n            repository.update_cart_items(service_res.unwrap())\n\n        case DuplicateItemInCartError():\n            logging.error(f\"Item {item} already exists in cart {cart_id}\")\n\n        case InvalidItemError():\n            logging.error(f\"Item {item} is not valid for cart {cart}\")\n</code></pre> <p>Now this is better! You can see the different possible flows within the <code>add_to_cart_aggregate</code>, without leaving  the same abstraction layer you can understand what happens in any case. That right there is the main compelling reason  to use this library.</p>"},{"location":"why_use_result/#not-everything-should-be-expressive","title":"Not everything should be expressive:","text":"<p>We present a few primitives for you to better express different possible flows of your application. But just because  you have the primitives does not necessarily mean you should use then everywhere!</p> <p>You should use <code>Result</code> as opposed to rising an <code>Exception</code> only when you consider that the exception is recoverable or manageable by the invoker.</p> <p>You can rely on Python's error handling when the behavior is impossible to recover from, an example would be a  <code>out of memory exception</code> or a <code>max recursive calls</code>. Basically whatever you consider as part of your program which  does not align well with railway programming concepts should be kept out of the loop.</p>"},{"location":"api/err_class_def/","title":"Error class documentation","text":"<p>Representation of an incorrect value derived from the flow of the program. Meaning this value holds the reference to the problem which derived in an incorrect state which was expected by the creators of the code.</p> class <code>toradh.Err</code>(err) async <code>async_if_ok</code>(self, op) <p>invoke the given an async operation in case of Ok() or else do nothing.</p> <p>Args:     op (Callable[[T], Any]): async function to invoke with the content of Ok()</p> <code>if_ok</code>(self, op) <p>invoke the given operation in case of Ok() or else do nothing.</p> <p>Args:     op (Callable[[T], Any]): function to invoke with the content of Ok()</p> <code>is_error</code>(self, _) <code>is_ok</code>(self) <code>kind</code>(self) <p>Returns the instance with the objective to be use for structural pattern matching.</p> <p>Returns:     E: Instance of the error withhold in the Err object.</p> <code>map_to_err</code>(self, err) <p>Give a new exception to return as a new instance of Err</p> <p>Args:     err (R): Exception to create Err[R]</p> <p>Returns:     Err[R]: New Err[R] instance object.</p> <code>or_else_throw</code>(self, result) <code>unwrap</code>(self) <p>Unwraps the contained exception</p> <p>Raises:     self._err: raises the exception.</p> <p>Returns:     NoReturn</p> <code>unwrap_or</code>(self, default) <code>unwrap_or_else</code>(self, op)"},{"location":"api/nothing_class_def/","title":"Intro to <code>Nothing</code>","text":"class <code>toradh.Nothing</code>() <code>empty</code>() <p>Creates an Nothing() instance which represent the absence of a value.</p> <p>Returns:     Nothing:</p> <code>is_none</code>(self) <code>is_nothing</code>(self) <p>checks if it is an instance of Some[T] or Nothing().</p> <p>Returns:     bool: True if it's an instance of Nothing() else False.</p> <code>is_some</code>(self) <code>map</code>(self, func) <code>of</code>(value) <p>Creates a instance of either Some() or Nothing, depending if the value if actually None or not.</p> <p>Args:     value (Union[T, None]): value to wrap.</p> <p>Returns:     Union[Some[T], Nothing]: Either an instance of Some[T] if T is not none else Nothing()</p> <code>unwrap</code>(self) <code>unwrap_or</code>(self, default)"},{"location":"api/ok_class_def/","title":"Ok class documentation","text":"<p>Representation of a correct value within the flow of the program. Meaning it's  this is the intended value by the creators of the code.</p> class <code>toradh.Ok</code>(value) async <code>async_if_ok</code>(self, op) <p>Given a Err result, call the op callable which should help resolve the error. Specifically designed for async callables.</p> <p>Args:     op (Callable[[E], T]): callable which should return a instance of T     given an instance of an error.</p> <p>Returns:     T:</p> <code>if_ok</code>(self, op) <p>invoke the given operation in case of Ok() or else do nothing.</p> <p>Args:     op (Callable[[T], Any]): function to invoke with the content of Ok()</p> <code>is_error</code>(self) <code>is_ok</code>(self) <code>kind</code>(self) <p>Returns the instance with the objective to be use for structural pattern matching.</p> <p>Returns:     T: wrapped instance</p> <code>or_else_throw</code>(self, result) <code>unwrap</code>(self) <p>Returns the wrapped instance.</p> <p>Returns:     T: instances wrapped by the Ok class.</p> <code>unwrap_or</code>(self, default) <p>Returns a default object in case the result is of the Err type.</p> <p>Args:     default (T): value to return in case of Err.</p> <p>Returns:     T: either the default value or the unwrapped value.</p> <code>unwrap_or_else</code>(self, op) <p>Given a Err result, call the op callable which should help resolve the error.</p> <p>Args:     op (Callable[[E], T]): callable which should return a instance of T     given an instance of an error.</p> <p>Returns:     T:</p>"},{"location":"api/option_class_def/","title":"Intro to <code>option</code>","text":"class <code>toradh.Option</code>(value) <code>empty</code>() <p>Creates an Nothing() instance which represent the absence of a value.</p> <p>Returns:     Nothing:</p> <code>is_nothing</code>(self) <p>checks if it is an instance of Some[T] or Nothing().</p> <p>Returns:     bool: True if it's an instance of Nothing() else False.</p> <code>is_some</code>(self) <p>checks if it is an instance of Some[T] or Nothing().</p> <p>Returns:     bool: True if it's an instance of Some() else False.</p> <code>map</code>(self, func) <code>of</code>(value) <p>Creates a instance of either Some() or Nothing, depending if the value if actually None or not.</p> <p>Args:     value (Union[T, None]): value to wrap.</p> <p>Returns:     Union[Some[T], Nothing]: Either an instance of Some[T] if T is not none else Nothing()</p> <code>unwrap</code>(self) <p>Returns the value wrapped in the Option Returns:     T: value wrapped.</p> <code>unwrap_or</code>(self, default) <p>Returns the value wrapped in case of Some() else returns the default value.</p> <p>Args:     default (T): value to return in case of Nothing()</p> <p>Returns:     T: returned value.</p>"},{"location":"api/result_intro/","title":"Intro to <code>Result</code>","text":"<p>One of the main benefits of <code>toradh</code> is the introduction of <code>Result</code> which is simply the union of 2 types: <code>Ok[T]</code> and <code>Err[E]</code>.</p> <p>both of this objects follow the blue prints of the below protocol.</p> class <code>toradh.result.ResultProto</code>(*args, **kwargs) async <code>async_if_ok</code>(self, op) <p>Given a Err result, call the op callable which should help resolve the error. Specifically designed for async callables.</p> <p>Args:     op (Callable[[E], T]): callable which should return a instance of T     given an instance of an error.</p> <p>Returns:     T:</p> <code>if_ok</code>(self, op) <p>invoke the given operation in case of Ok() or else do nothing.</p> <p>Args:     op (Callable[[T], Any]): function to invoke with the content of Ok()</p> <code>is_error</code>(self) <p>Helper function to check if the instance if of type Err</p> <p>Returns:     bool: True if Err() instance, else False</p> <code>is_ok</code>(self) <p>Helper function to check if the instance if of type Ok</p> <p>Returns:     bool: True if Ok() instance, else False</p> <code>kind</code>(self) <p>Returns the instance with the objective to be use for structural pattern matching.</p> <p>Returns:     T: wrapped instance</p> <code>map_to_err</code>(self, result) <p>Give a new exception to return as a new instance of Err</p> <p>Args:     err (R): Exception to create Err[R]</p> <p>Returns:     Err[R]: New Err[R] instance object.</p> <code>unwrap</code>(self) <p>Returns the wrapped instance.</p> <p>Returns:     T: instances wrapped by the Ok class.</p> <code>unwrap_or</code>(self, default) <p>Returns a default object in case the result is of the Err type.</p> <p>Args:     default (T): value to return in case of Err.</p> <p>Returns:     T: either the default value or the unwrapped value.</p> <code>unwrap_or_else</code>(self, op) <p>Given a Err result, call the op callable which should help resolve the error.</p> <p>Args:     op (Callable[[E], T]): callable which should return a instance of T     given an instance of an error.</p> <p>Returns:     T:</p>"},{"location":"api/some_class_def/","title":"Intro to <code>Some</code>","text":"class <code>toradh.Some</code>(value) <code>empty</code>() <p>Creates an Nothing() instance which represent the absence of a value.</p> <p>Returns:     Nothing:</p> <code>is_nothing</code>(self) <p>checks if it is an instance of Some[T] or Nothing().</p> <p>Returns:     bool: True if it's an instance of Nothing() else False.</p> <code>is_some</code>(self) <p>checks if it is an instance of Some[T] or Nothing().</p> <p>Returns:     bool: True if it's an instance of Some() else False.</p> <code>map</code>(self, func) <code>of</code>(value) <p>Creates a instance of either Some() or Nothing, depending if the value if actually None or not.</p> <p>Args:     value (Union[T, None]): value to wrap.</p> <p>Returns:     Union[Some[T], Nothing]: Either an instance of Some[T] if T is not none else Nothing()</p> <code>unwrap</code>(self) <p>Returns the value wrapped in the Option Returns:     T: value wrapped.</p> <code>unwrap_or</code>(self, default) <p>Returns the value wrapped in case of Some() else returns the default value.</p> <p>Args:     default (T): value to return in case of Nothing()</p> <p>Returns:     T: returned value.</p>"}]}